/*globals define, WebGMEGlobal*/
/*jshint browser: true*/
/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Thu Sep 21 2017 23:09:07 GMT-0500 (CDT).
 */

define([
    'js/Constants',
    'q',
    'common/util/ejs',
    'scsrc/templates/ejsCache',
    'scsrc/util/utils'
], function (
    CONSTANTS,
    Q,
    ejs,
    ejsCache,
    utils
) {

    'use strict';

    var SolidityCodeEditorControl;

    SolidityCodeEditorControl = function (options) {

        this._logger = options.logger.fork('Control');

        this._client = options.client;

        // Initialize core collections and variables
        this._widget = options.widget;

        this._currentNodeId = null;
        this._gatheringSegments = false;
        this._missedEvents = false;

        this._territory = null;
        this._segmentInfo = {};
        this._UID = null;

        this._initialize();

        this._logger.debug('ctor finished');
    };

    SolidityCodeEditorControl.prototype._initialize = function () {
        var self = this;

        this._UID = this._client.addUI(self, function (events) {
            self._eventCallback(events);
        });

        this._initWidgetEventHandlers();
    };

    SolidityCodeEditorControl.prototype._initWidgetEventHandlers = function () {
        var self = this;
        this._widget.onSave = function (segmentedDocumentObject) {
            // console.log(segmentedDocumentObject);
            self._SaveDocument(segmentedDocumentObject);
        };
    };

    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).
    SolidityCodeEditorControl.prototype.selectedObjectChanged = function (nodeId) {
        if (typeof nodeId === 'string' &&
            this._currentNodeId !== nodeId &&
            this._client.getNode(this._client.getNode(nodeId).getMetaTypeId())
                .getAttribute('name') === 'Contract') {
            //we have a viable contract so let us change things
            this._currentNodeId = nodeId;
            this._selfPatterns = {};
            this._selfPatterns[nodeId] = {children: 1};
            this._client.updateTerritory(this._UID, this._selfPatterns);
        } else {
            this._logger.info('received unwanted object change event');
        }
    };

    SolidityCodeEditorControl.prototype._getContractModel = function (cTypeId) {
        var self = this,
            deferred = Q.defer(),
            model = {},
            context;

        Q.ninvoke(self._client, 'getCoreInstance', {})
            .then(function (context_) {
                context = context_;
                return context.core.loadByPath(context.rootNode, cTypeId);
            })
            .then(function (contract) {
                if (contract) {
                    return utils.getModelOfContract(context.core, contract);
                } else {
                    throw new Error('Contract was removed!');
                }
            })
            .then(deferred.resolve)
            .catch(deferred.reject);

        return deferred.promise;
    };

    SolidityCodeEditorControl.prototype._getSegmentOffset = function (segmentedDocument, segmentId) {
        var compiledText = '',
            index = 0,
            sId = segmentedDocument.composition[0] || null;

        while (sId !== null && sId !== segmentId && index < segmentedDocument.composition.length) {
            compiledText += segmentedDocument.segments[sId].value + '\n';
            sId = segmentedDocument.composition[++index];
        }

        return compiledText.split('\n').length;
    };

    SolidityCodeEditorControl.prototype._buildSegmentInfo = function (nodeId) {
        var self = this,
            deferred = Q.defer(),
            model,
            segmentId,
            //guardNames = [],
            //guardExpressionParser,
            addSegment = function (segmentId, segmentPath, segmentModel, readonly) {
                var fullSegmentId = segmentId + '*' + segmentPath;

                segmentedDocument.composition.push(fullSegmentId);
                segmentedDocument.segments[fullSegmentId] = {
                    value: ejs.render(ejsCache.contractType[segmentId], segmentModel),
                    options: {readonly: readonly === true}
                };
              return fullSegmentId;
            },
            segmentedDocument = {composition: [], segments: {}, errors: []};

        self._getContractModel(nodeId)
            .then(function (model_) {
                var i,
                    wholeDocument = ejs.render(ejsCache.contractType.complete, model_),
                    parseResult;

                model = model_;
                //parseResult = javaParser.checkWholeFile(wholeDocument);

                //if (parseResult) {
                //    segmentedDocument.errors.push(parseResult);
                //}

                //for (i = 0; i < model.guards.length; i += 1) {
                //    guardNames.push(model.guards[i].name);
                //}
                //if (guardNames.length > 0) {
                //    guardExpressionParser = peg.generate(
                //        ejs.render(ejsCache.guardExpression, {guardNames: guardNames})
                //    );
                //}

                //addSegment('constantImports', model.path, model, true);
                //addSegment('userImports', model.path, model);
                //addSegment('portsAnnotations', model.path, model, true);
                addSegment('classStart', model.path, model, true);

                addSegment('states', model.path, model, true);
                addSegment('userDefinitions', model.path, model);
                //addSegment('plugins', model.path, model, true);
                //addSegment('classInitializations', model.path, model, true);
                //addSegment('userConstructors', model.path, model);

                for (i = 0; i < model.transitions.length; i += 1) {
                    segmentId = addSegment('singleTransitionStart', model.transitions[i].path, model.transitions[i], true);
                    segmentId += addSegment('singleTransitionArguments', model.transitions[i].path, model.transitions[i]);
                    //segmentId += addSegment('singleTransitionPlugins', model.transitions[i].path, model.transitions[i], true);
                    segmentId += addSegment('singleTransitionStartEnd', model.transitions[i].path, model.transitions[i], true);
                    //if (model.transitions[i].output !== '')
                    segmentId += addSegment('singleTransitionReturn', model.transitions[i].path, model.transitions[i], true);
                    segmentId += addSegment('singleTransitionOutput', model.transitions[i].path, model.transitions[i]);
                    segmentId += addSegment('singleTransitionRequireState', model.transitions[i].path, model.transitions[i], true);
                    segmentId += addSegment('singleTransitionRequireGuards', model.transitions[i].path, model.transitions[i], true);
                    segmentId += addSegment('singleTransitionGuards', model.transitions[i].path, model.transitions[i]);
                    segmentId += addSegment('singleTransitionEndGuards', model.transitions[i].path, model.transitions[i], true);
                    segmentId += addSegment('singleTransitionStatements', model.transitions[i].path, model.transitions[i]);
                    segmentId += addSegment('singleTransitionStateChange', model.transitions[i].path, model.transitions[i], true);

                    //parseResult = javaParser.checkForSingleFunction(
                    //    segmentedDocument.segments[segmentId].value,
                    //    null,
                    //    'public',
                    //    self._getSegmentOffset(segmentedDocument, segmentId));
                    //if (parseResult) {
                    //    segmentedDocument.errors.push(parseResult);
                    //}
                }
                addSegment('classEnd', model.path, model, true);
                deferred.resolve(segmentedDocument);
            })
            .catch(deferred.reject);

        return deferred.promise;
    };

    SolidityCodeEditorControl.prototype._SaveDocument = function (changedSegments) {
        var segment,
            segmentId;

        this._client.startTransaction();
        for (segmentId in changedSegments) {
            segment = changedSegments[segmentId];
            segmentId = segmentId.split('*');

            switch (segmentId[0]) {
                //case 'userImports':
                //    this._client.setAttribute(segmentId[1], 'forwards', segment);
                //    break;
                case 'userDefinitions':
                    this._client.setAttribute(segmentId[1], 'definitions', segment);
                    break;
                    //TODO: Update
                case 'singleTransitionGuards':
                    this._client.setAttribute(segmentId[1], 'guards', segment);
                    break;
                case 'singleTransitionOutput':
                    this._client.setAttribute(segmentId[1], 'output', segment);
                    break;
                case 'singleTransitionArguments':
                    this._client.setAttribute(segmentId[1], 'input', segment);
                    break;
                case 'singleTransitionStatements':
                    this._client.setAttribute(segmentId[1], 'statements', segment);
                    break;
                //case 'singleGuard':
                //    this._client.setAttribute(segmentId[1], 'guardMethod', segment);
                //    break;
            }
        }
        this._client.completeTransaction();
    };

    /* * * * * * * * Node Event Handling * * * * * * * */
    //TODO needs a better change management
    SolidityCodeEditorControl.prototype._eventCallback = function (events) {
        var self = this,
            componentRemoved = false,
            i;

        if (events.length > 1) {
            if (self._gatheringSegments) {
                self._missedEvents = true;
            } else {
                for (i = 0; i < events.length; i += 1) {
                    if (events[i].eid === this._currentNodeId && events[i].etype === CONSTANTS.TERRITORY_EVENT_UNLOAD) {
                        componentRemoved = true;
                        break;
                    }
                }
                if (componentRemoved !== true) {
                    self._buildSegmentInfo(this._currentNodeId)
                        .then(function (segmentedDocumentObject) {
                            self._gatheringSegments = false;
                            if (self._missedEvents) {
                                self._missedEvents = false;
                                self._eventCallback([{
                                    eid: self._currentNodeId,
                                    etype: CONSTANTS.TERRITORY_EVENT_UPDATE
                                }, {}]);
                            } else {
                                self._widget.setSegmentedDocument(segmentedDocumentObject);
                            }
                        })
                        .catch(function (err) {
                            self._gatheringSegments = false;
                            self._logger.error('error during segment info build:', err);
                            if (self._missedEvents) {
                                self._missedEvents = false;
                                self._eventCallback([{
                                    eid: self._currentNodeId,
                                    etype: CONSTANTS.TERRITORY_EVENT_UPDATE
                                }, {}]);
                            }
                        });
                }
            }
        }
    };

    SolidityCodeEditorControl.prototype._stateActiveObjectChanged = function (model, activeObjectId) {
        if (this._currentNodeId === activeObjectId) {
            // The same node selected as before - do not trigger
        } else {
            this.selectedObjectChanged(activeObjectId);
        }
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    SolidityCodeEditorControl.prototype.destroy = function () {
        this._detachClientEventListeners();
        this._removeToolbarItems();
    };

    SolidityCodeEditorControl.prototype._attachClientEventListeners = function () {
        this._detachClientEventListeners();
        WebGMEGlobal.State.on('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged, this);
    };

    SolidityCodeEditorControl.prototype._detachClientEventListeners = function () {
        WebGMEGlobal.State.off('change:' + CONSTANTS.STATE_ACTIVE_OBJECT, this._stateActiveObjectChanged);
    };

    SolidityCodeEditorControl.prototype.onActivate = function () {
        this._attachClientEventListeners();
        this._displayToolbarItems();

        if (typeof this._currentNodeId === 'string') {
            WebGMEGlobal.State.registerActiveObject(this._currentNodeId, {suppressVisualizerFromNode: true});
        }
    };

    SolidityCodeEditorControl.prototype.onDeactivate = function () {
        this._detachClientEventListeners();
        this._hideToolbarItems();
    };

    /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
    SolidityCodeEditorControl.prototype._displayToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].show();
            }
        } else {
            this._initializeToolbar();
        }
    };

    SolidityCodeEditorControl.prototype._hideToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].hide();
            }
        }
    };

    SolidityCodeEditorControl.prototype._removeToolbarItems = function () {

        if (this._toolbarInitialized === true) {
            for (var i = this._toolbarItems.length; i--;) {
                this._toolbarItems[i].destroy();
            }
        }
    };

    SolidityCodeEditorControl.prototype._initializeToolbar = function () {
        // var self = this,
        //     toolBar = WebGMEGlobal.Toolbar;

        this._toolbarItems = [];

        // this._toolbarItems.push(toolBar.addSeparator());
        //
        // /************** Go to hierarchical parent button ****************/
        // this.$btnModelHierarchyUp = toolBar.addButton({
        //     title: 'Go to parent',
        //     icon: 'glyphicon glyphicon-circle-arrow-up',
        //     clickFn: function (/*data*/) {
        //         WebGMEGlobal.State.registerActiveObject(self._currentNodeParentId);
        //     }
        // });
        // this._toolbarItems.push(this.$btnModelHierarchyUp);
        // this.$btnModelHierarchyUp.hide();
        //
        // /************** Checkbox example *******************/
        //
        // this.$cbShowConnection = toolBar.addCheckBox({
        //     title: 'toggle checkbox',
        //     icon: 'gme icon-gme_diagonal-arrow',
        //     checkChangedFn: function (data, checked) {
        //         self._logger.debug('Checkbox has been clicked!');
        //     }
        // });
        // this._toolbarItems.push(this.$cbShowConnection);

        this._toolbarInitialized = true;
    };

    return SolidityCodeEditorControl;
});
